<html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org"
      xmlns:sec="https://www.thymeleaf.org/thymeleaf-extras-springsecurity5">
    <title>WebRTC demo</title>
    <div th:replace="fragments/header :: header-css"/>
</head>
<style>
    body {
        /*display: block;*/
        align-items: center;
        justify-content: center;
        font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        font-size: 16px;
        height: 100vh;
    }
    .content {
        box-shadow: rgba(156, 172, 172, 0.2) 0px 2px 2px, rgba(156, 172, 172, 0.2) 0px 4px 4px, rgba(156, 172, 172, 0.2) 0px 8px 8px, rgba(156, 172, 172, 0.2) 0px 16px 16px, rgba(156, 172, 172, 0.2) 0px 32px 32px, rgba(156, 172, 172, 0.2) 0px 64px 64px;
        border-radius: 3px;
        height: 100vh;
        max-height: 600px;
        width: 100vw;
        max-width: 400px;
        display: flex;
        flex-direction: column;
        margin-left: auto;
        margin-right: auto;
    }
    .messages {
        flex-grow: 1;
        padding: 20px 30px;
        overflow: auto;
    }
    .message {
        display: flex;
        flex-direction: column;
    }
    .message--mine {
        align-items: flex-end;
    }
    .message--theirs {
        align-items: flex-start;
    }
    .message__name {
        padding: 10px 0;
    }
    .message__bubble {
        padding: 20px;
        border-radius: 3px;
    }
    .message--theirs .message__bubble {
        background: #6363bf;
        color: white;
    }
    .message--mine .message__bubble {
        background: rgba(156, 172, 172, 0.2);
    }
    .footer {
        line-height: 76px;
        border-top: 1px solid rgba(156, 172, 172, 0.2);
        display: flex;
        flex-shrink: 0;
    }
    input {
        height: 76px;
        border: none;
        flex-grow: 1;
        padding: 0 30px;
        font-size: 16px;
        background: transparent;
    }
    button {
        border: none;
        background: transparent;
        padding: 0 30px;
        font-size: 16px;
        cursor: pointer;
    }

</style>
<body>
<div th:replace="fragments/header :: header"/>


<div class="content">
    <button type="button" class="btn btn-primary" onclick='createOffer()'>Create Offer</button>
    <div class="messages">

    </div>
    <form class="footer" onsubmit="return false;">
        <input id="messageInput"  type="text" placeholder="Your message..">
        <button type="submit" onclick='sendMessage()'>Send</button>
    </form>
</div>

<template data-template="message">
    <div class="message">
        <div class="message__name"></div>
        <div class="message__bubble"></div>
    </div>
</template>

<!--WebRTC related code-->


<!--<input id="messageInput" type="text" class="form-control" placeholder="message">-->

<!--<button type="button" class="btn btn-primary" '>SEND</button>-->

<center>
    <video id="video-from-camera" autoplay style="max-width: 300px;"></video>
    <!-- <canvas id="video-canvas" style="height: 480px; width: 720px;"></canvas><br /><br /> -->
</center>

<div th:replace="fragments/footer :: footer"/>
<script>
    const possibleEmojis = [
        'ğŸ€','ğŸ','ğŸ­','ğŸ¹','ğŸ‚','ğŸƒ','ğŸ„','ğŸ®','ğŸ…','ğŸ†','ğŸ¯','ğŸ‡','ğŸ','ğŸ‘','ğŸ','ğŸ´',
        'ğŸ','ğŸ±','ğŸˆ','ğŸ°','ğŸ“','ğŸ”','ğŸ¤','ğŸ£','ğŸ¥','ğŸ¦','ğŸ§','ğŸ˜','ğŸ©','ğŸ•','ğŸ·','ğŸ–',
        'ğŸ—','ğŸ«','ğŸª','ğŸ¶','ğŸº','ğŸ»','ğŸ¨','ğŸ¼','ğŸµ','ğŸ™ˆ','ğŸ™‰','ğŸ™Š','ğŸ’','ğŸ‰','ğŸ²','ğŸŠ',
        'ğŸ','ğŸ¢','ğŸ¸','ğŸ‹','ğŸ³','ğŸ¬','ğŸ™','ğŸŸ','ğŸ ','ğŸ¡','ğŸš','ğŸŒ','ğŸ›','ğŸœ','ğŸ','ğŸ',
    ];

    function randomEmoji() {
        var randomIndex = Math.floor(Math.random() * possibleEmojis.length);
        return possibleEmojis[randomIndex];
    }

    //connecting to our signaling server
    let conn = new WebSocket('ws://localhost:8080/socket');
    let name = $("#name").html();
    const emoji = randomEmoji();

    conn.onopen = function() {
        console.log("Connected to the signaling server");
        initialize();
    };

    conn.onmessage = function(msg) {
        console.log("Got message", msg.data);
        var content = JSON.parse(msg.data);
        var data = content.data;
        switch (content.event) {
            // when somebody wants to call us
            case "offer":
                handleOffer(data);
                break;
            case "answer":
                handleAnswer(data);
                break;
            // when a remote peer sends an ice candidate to us
            case "candidate":
                handleCandidate(data);
                break;
            default:
                break;
        }
    };

    function send(message) {
        conn.send(JSON.stringify(message));
    }

    var peerConnection;
    var dataChannel;
    var input = document.getElementById("messageInput");

    function initialize() {
        var configuration = null;

        peerConnection = new RTCPeerConnection(configuration, {
            optional : [ {
                RtpDataChannels : true
            } ]
        });

        // Setup ice handling
        peerConnection.onicecandidate = function(event) {
            if (event.candidate) {
                send({
                    event : "candidate",
                    data : event.candidate
                });
            }
        };

        // creating data channel
        dataChannel = peerConnection.createDataChannel("dataChannel", {
            reliable : true
        });

        dataChannel.onerror = function(error) {
            console.log("Error occured on datachannel:", error);
        };

        // ........................................RECEIVING MESSAGE ....................................................
        dataChannel.onmessage = function(event) {
            insertMessageToDOM(JSON.parse(event.data), false)
        };

        dataChannel.onclose = function() {
            console.log("data channel is closed");
        };
    }

    function insertMessageToDOM(options, isFromMe) {
        const template = document.querySelector('template[data-template="message"]');
        const nameEl = template.content.querySelector('.message__name');

        if (options.name) {
            nameEl.innerText = options.emoji + ' ' + options.name;
        }
        template.content.querySelector('.message__bubble').innerText = options.content;
        const clone = document.importNode(template.content, true);
        const messageEl = clone.querySelector('.message');

        if (isFromMe) {
            messageEl.classList.add('message--mine');
        } else {
            messageEl.classList.add('message--theirs');
        }
        const messagesEl = document.querySelector('.messages');
        messagesEl.appendChild(clone);

        // Scroll to bottom
        messagesEl.scrollTop = messagesEl.scrollHeight - messagesEl.clientHeight;
        // console.log(options.name + ": " + options.content);
    }

    function createOffer() {
        peerConnection.createOffer(function(offer) {
            send({
                event : "offer",
                data : offer
            });
            peerConnection.setLocalDescription(offer);
        }, function(error) {
            alert("Error creating an offer");
        });
    }

    function handleOffer(offer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

        // create and send an answer to an offer
        peerConnection.createAnswer(function(answer) {
            peerConnection.setLocalDescription(answer);
            send({
                event : "answer",
                data : answer
            });
        }, function(error) {
            alert("Error creating an answer");
        });

    };

    function handleCandidate(candidate) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    };

    function handleAnswer(answer) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        console.log("connection established successfully!!");
    };

    function sendMessage() {
        console.log(name, ": ", input.value);

        const data = {
            name,
            content: input.value,
            emoji,
        };
        input.value = "";
        dataChannel.send(JSON.stringify(data));

        insertMessageToDOM(data, true);
    }
</script>
<!--WebRTC related code-->
</body>

</html>